/* NOTE: if I want to do logging, I had an idea for that:
 * HAVE THE USER PASS function pointers to a logging function that they 
 * write? as long as the function they write takes in a format string 
 * and variadic args it works? then they can kinda take it from there as 
 * far as how they want to print the messages
 * or better yet just turn logging off!
 */

^ this has been implemented 

/* NOTE: goal is to have a header only string library that can compile
 * to c89 with 0 dependencies (including C standard library)
 */

/* NOTE: list of string functions to implement:
 * x compare two strings
 *   - equals convenience function as well (i.e. are the two strings
 *   equal).
 * - concatenate strings
 * - copy (can copy substring of one string to substring of other string)
 * - begins with (substring or char)
 * - ends with (substring or char)
 * - begins with (substring or char)
 * - format (create a string from a given format string? this seems
 *   complicated, but is obv very useful. actually you know what, you
 *   can do it bro wtheck ofc u can) 
 * - index of: get index of a char or substring
 * - last index of
 * - insert: insert char or substring at an index
 * - is_empty: simple convenience function I guess? is this useful at
 *   all?
 * - join: concatenates strings or list of strings with a given
 *   "separator" in between each string (i.e. a list with ", " between
 *   each string or smn could be a use case)
 * - remove: remove instances of char or substring or characters at a 
 *   given index -> a few possible versions of this one, make them all
 * - replace: replace chars at a given index or replace instances of
 *   char or substring with char or substring
 * - split: like strtok but actually good basically
 * - to upper/to lower
 * - trim: remove whitespace from beginning or end, or like all whitespace
 *   idk that could be useful too
 * 
 * so there ya go! good luck :) - josh
 *
 */

/* NOTE: could have like a free-list type thing, where if strings get 
 * "freed" we flag that so that we can fill those empty "blocks" later...
 * simpler would be a linear allocator ? 
 * maybe there's 2 types of strings - permanent, and temporary
 * we have a function that wipes temporary? and temporary is a bump 
 * allocator permanent also a bump allocator that gets freed at the 
 * end... ? that seems like it covers most use cases as long as there's 
 * enough storage for "permanent" strings. Note also the way the 
 * library is setup, permanent strings should be able to be
 * stored in place -> WAIT PROBLEM THO, if we add to strings, 
 * concatenate, insert etc... how do we account for that?
 * okay, this is an interesting problem space... maybe we do need like 
 * a first-fit free list (or red-black tree for efficiency <- more likely)
 * that allocates double the string size to leave room and then like 
 * moves strings if it has to? I just feel like the more can be done 
 * to strings IN PLACE the better
 */ 

/* NOTE: for now I'm going to do just a temporary store that we can 
 * clear periodically or whatever to get the functions up and running 
 * because I feel like writing code that does stuff rather than thinking 
 * a whole bunch. And I feel like the string processing
 * problem space needs to be fleshed out more in my head before I can 
 * make decisions about how to manage the memory around it... does that 
 * make sense? 
 */

 /* TODO: unit testing */
